#include "ImagePacket.h"
#include "Request.h"
#include "Util.h"
#include <arpa/inet.h>
#include <chrono>
#include <fstream>
#include <iostream>
#include <string>
#include <thread>
#include <vector>

using namespace std;

void saveFile(string path, char *bytes, unsigned size) {
  ofstream file(path, ios::binary);
  file.write(bytes, size);
  file.close();
}

void requestScreenShots(string serverIp, int port,
                                unsigned short quality, unsigned int interval) {
  size_t len_reply;
  while (true) {
    try {
      ImagePacket *imgpack = (ImagePacket *)Request::doOperation(
          serverIp, port, Message::AllowedOperations::image,
          (char *)new ImagePacket("aux", quality, nullptr, 0), sizeof(ImagePacket), len_reply);
      cout << "salioo" << endl;
      cout << len_reply << endl;
      cout << imgpack->name << endl;
      cout << imgpack->quality << endl;
      saveFile("ScreenShots/" + string(imgpack->name), imgpack->bytes,
               len_reply - sizeof(char) * string(imgpack->name).size() -
                   sizeof(unsigned short));
    } catch (const char *msg) {
      std::cerr << msg << endl;
    }
    std::this_thread::sleep_for(std::chrono::seconds(interval));
  }
}

int main(int argc, char *argv[]) {
  ios_base::sync_with_stdio(0);
  string firstServerIp;
  uint16_t port;
  int serversCount, interval;
  unsigned short quality;
  cout << "Ingrese el numero de servidores: ";
  cin >> serversCount;
  cout << "Ingrese la direccion ip del primer servidor";
  cin >> firstServerIp;
  cout << "Ingrese el puerto que utilizaran los servidores: ";
  cin >> port;
  cout << "Ingrese la calidad de las capturas de pantalla que se recibiran: ";
  cin >> quality;
  cout << "Intervalo de tiempo en el que se solicitaran las capturas de "
          "panalla: ";
  cin >> interval;
  cout << endl;
  int firstIp = ntohl(inet_addr(firstServerIp.c_str()));
  int lastIP = firstIp + serversCount - 1;
  vector<thread> requests;
  for (int i = firstIp; i != lastIP + 1; i++) {
    struct in_addr addr;
    addr.s_addr = htonl(i);
    string serverIp = string(inet_ntoa(addr));
    requests.emplace_back(requestScreenShots, serverIp, port, quality,
                          interval);
  }

  for (auto &th : requests) {
    th.join();
  }
  return 0;
}

***********************************************************
#include "DatagramPacket.h"

DatagramPacket::DatagramPacket(char* const buf, size_t len): port(0), address("") {
  setData(buf, len);
}

DatagramPacket::DatagramPacket(char* const buf, size_t len, const std::string & addr, uint16_t iport) {
  setData(buf, len);
  setAddress(addr);
  setPort(iport);
}

std::string DatagramPacket::getAddress() {
  return address;
}

uint16_t DatagramPacket::getPort() {
  return port;
}

char* DatagramPacket::getData() {
  return buffer;
}

size_t DatagramPacket::getLength() {
  return length;
}

void DatagramPacket::setAddress(const std::string & addr) {
  address = addr;
}

void DatagramPacket::setPort(uint16_t iport) {
  port = iport;
}

void DatagramPacket::setLength(size_t len) {
  length = len;
}

void DatagramPacket::setData(char* const buf, size_t len) {
  buffer = buf;
  setLength(len);
}

-----------------------------------------------------------

#include <cstddef>
#include <string>

#ifndef DatagramPacket_H_
#define DatagramPacket_H_

class DatagramPacket {
  public:
    DatagramPacket(char* const buf, size_t len);
    DatagramPacket(char* const buf, size_t len, const std::string & addr, uint16_t iport);
    std::string getAddress();
    char *getData();
    size_t getLength();
    uint16_t getPort();
    void setAddress(const std::string & addr);
    void setData(char* const buf, size_t len);
    void setLength(size_t len);
    void setPort(uint16_t iport);

  private:
    char *buffer;
    uint16_t port;
    std::string address;
    size_t length;
};

#endif

****************************************************

#include "DatagramSocket.h"
#include <arpa/inet.h>
#include <iostream>
#include <netinet/in.h>
#include <strings.h>
#include <sys/socket.h>
#include <unistd.h>

DatagramSocket::DatagramSocket() : DatagramSocket(0) {}

DatagramSocket::DatagramSocket(uint16_t iport)
    : DatagramSocket(iport, "0.0.0.0") {}

DatagramSocket::DatagramSocket(uint16_t iport, const std::string &addr) {
  s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

  bzero((char *)&localAddress, sizeof(localAddress));
  localAddress.sin_family = AF_INET;
  localAddress.sin_addr.s_addr = inet_addr(addr.c_str());
  localAddress.sin_port = htons(iport);
  bind(s, (struct sockaddr *)&localAddress, sizeof(localAddress));
}

DatagramSocket::~DatagramSocket() { unbind(); }

void DatagramSocket::unbind() {
  close(s);
  s = 0;
}

int DatagramSocket::receive(DatagramPacket &p) {
  socklen_t len = sizeof(remoteAddress);
  int n = recvfrom(s, p.getData(), p.getLength(), 0,
                   (struct sockaddr *)&remoteAddress, &len);
  p.setPort(ntohs(remoteAddress.sin_port));
  p.setAddress(std::string(inet_ntoa(remoteAddress.sin_addr)));
  p.setLength(n);
  return n;
}

int DatagramSocket::receiveTimeout(DatagramPacket &p, time_t seconds,
                                   suseconds_t microseconds) {
  timeout.tv_sec = seconds;
  timeout.tv_usec = microseconds;
  setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof(timeout));

  socklen_t len = sizeof(remoteAddress);

  int n = recvfrom(s, p.getData(), p.getLength(), 0,
                   (struct sockaddr *)&remoteAddress, &len);

  if (n < 0) {
    if (errno == EWOULDBLOCK)
      throw "Timeout while receiving the packet";
    else
      throw "Error while receiving the packet";
  }

  p.setPort(ntohs(remoteAddress.sin_port));
  p.setAddress(std::string(inet_ntoa(remoteAddress.sin_addr)));
  p.setLength(n);
  return n;
}

int DatagramSocket::send(DatagramPacket &p) {
  bzero((char *)&remoteAddress, sizeof(remoteAddress));
  remoteAddress.sin_family = AF_INET;
  remoteAddress.sin_port = htons(p.getPort());
  remoteAddress.sin_addr.s_addr = inet_addr(p.getAddress().c_str());
  return sendto(s, p.getData(), p.getLength(), 0,
                (struct sockaddr *)&remoteAddress, sizeof(remoteAddress));
}

-----------------------------------------------------------

#include <cstddef>
#include <string>
#include <netinet/in.h>
#include "DatagramPacket.h"

#ifndef DatagramSocket_H_
#define DatagramSocket_H_

class DatagramSocket {
  public:
    DatagramSocket();
    DatagramSocket(uint16_t iport);
    DatagramSocket(uint16_t iport, const std::string & addr);
    ~DatagramSocket();
    void unbind();
    int send(DatagramPacket &p);
    int receive(DatagramPacket &p);
    int receiveTimeout(DatagramPacket & p, time_t seconds, suseconds_t microseconds);

  private:
    struct sockaddr_in localAddress;
    struct sockaddr_in remoteAddress;
    int s;
    struct timeval timeout;
};

#endif

*************************************************************

#include "ImagePacket.h"
#include <string.h>

ImagePacket::ImagePacket() {}
#include <iostream>
using namespace std;
ImagePacket::ImagePacket(const char *name, unsigned short quality, char *img,
                         size_t len)
    : quality(quality) {
  strcpy(this->name, name);
  if (len) {
    memcpy(bytes, img, len);
  }
}

-------------------------------------------------------------

#ifndef IMAGEPACKET_H
#define IMAGEPACKET_H
#include <string>
class ImagePacket {
  public:
    const static size_t MAX_SIZE = 1e6;
    ImagePacket();
    ImagePacket(const char * name, unsigned short quality, char * bytes, size_t len);
    char name[100];
    unsigned short quality;
    char bytes[MAX_SIZE];
    size_t len;
};
#endif

**************************************************************

all: client server

DatagramPacket.o: DatagramPacket.cpp
  g++ -c DatagramPacket.cpp -Wall

DatagramSocket.o: DatagramSocket.cpp
  g++ -c DatagramSocket.cpp -Wall

Request.o: Request.cpp
  g++ -c Request.cpp -Wall

Reply.o: Reply.cpp
  g++ -c Reply.cpp -Wall

Util.o: Util.cpp
  g++ -c Util.cpp -Wall

ImagePacket.o: ImagePacket.cpp
  g++ -c ImagePacket.cpp -Wall

client: Util.o ImagePacket.o DatagramPacket.o DatagramSocket.o Request.o Reply.o
  g++ Util.o ImagePacket.o DatagramPacket.o DatagramSocket.o Request.o Reply.o client.cpp -o client -lpthread

server: Util.o ImagePacket.o DatagramPacket.o DatagramSocket.o Request.o Reply.o
  g++ Util.o ImagePacket.o DatagramPacket.o DatagramSocket.o Request.o Reply.o server.cpp -o server -lpthread

.PHONY: clean

clean:
  rm -rf *.o *.exe server client

**********************************************************************

#ifndef MESSAGE_H
#define MESSAGE_H

class Message {
  public:
    enum Type: int {request, reply};
    enum AllowedOperations: int {sum, transfer, getBalance, image};
    static const size_t MAX_DATA_SIZE = 35000;
    Message::Type type;    
    uint64_t requestId;
    Message::AllowedOperations operation;
    char arguments[MAX_DATA_SIZE];
    size_t length;
    bool MF;
    unsigned offset;
};
#endif

***************************************************************************

#include "Reply.h"
#include <iostream>
#include <string.h>

#include "ImagePacket.h"

Reply::Reply(int iport) { localSocket = new DatagramSocket(iport); }

Message *Reply::getRequest() {
  Message *msg = new Message();
  DatagramPacket pq((char *)msg, sizeof(Message));
  localSocket->receive(pq);

  address = pq.getAddress();
  port = pq.getPort();
  operation = msg->operation;
  requestId = msg->requestId;
  if (history.count({address, requestId})) {
    auto saved = history[{address, requestId}];
    std::cout << msg->offset << "/" << saved.second << std::endl;
    sendReply(saved.first + msg->offset, saved.second - msg->offset);
    return getRequest();
  }
  return msg;
}

void Reply::sendReply(const char *arguments, size_t len) {
  if (!history.count({address, requestId}))
    history[{address, requestId}] = {arguments, len};
  Message *msg = new Message();
  msg->type = Message::Type::reply;
  msg->operation = operation;
  msg->requestId = requestId;
  msg->length = len;

  if (msg->length > Message::MAX_DATA_SIZE) {
    msg->MF = 1;
    msg->length = Message::MAX_DATA_SIZE;
  }

  memcpy(msg->arguments, arguments, msg->length);

  DatagramPacket paquete((char *)msg, sizeof(Message), address, port);
  localSocket->send(paquete);
}
-------------------------------------------------------------------------------------------

#include "DatagramSocket.h"
#include "Message.h"
#include <map>
#include <utility>

#ifndef REPLY_H
#define REPLY_H

class Reply {
  public:
    Reply(int iport);
    Message *getRequest();
    void sendReply(const char *arguments, size_t len);
    std::string address;
    uint16_t port;
    uint64_t requestId;
  private:
    DatagramSocket *localSocket;
    std::map<std::pair<std::string, uint64_t>, std::pair<const char*, size_t>> history;
    Message::AllowedOperations operation;
};

#endif


*****************************************************************************************************

#include "Request.h"
#include "Util.h"
#include <chrono>
#include <iostream>
#include <random>
#include <stdlib.h>
#include <string.h>

#include "ImagePacket.h"

char *Request::doOperation(const std::string addr, uint16_t iport,
                           Message::AllowedOperations operation,
                           char *arguments, size_t len, size_t &len_reply) {
  char *ans = new char[0];
  Message *msgToReceive = new Message();
  msgToReceive->MF = 1;
  Message *msgToSend = new Message();
  msgToSend->type = Message::Type::request;
  msgToSend->requestId =
      Util::random(0ull, std::numeric_limits<unsigned long long>::max());
  msgToSend->operation = operation;
  memcpy(msgToSend->arguments, arguments, len);
  msgToSend->length = len;
  DatagramPacket pq((char *)msgToSend, sizeof(Message), addr, iport);
  DatagramSocket sock;
  while (msgToReceive->MF == 1) {
    DatagramPacket pqresp((char *)msgToReceive, sizeof(Message));
    int i;
    for (i = 0; i < 7; i++) {
      try {
        sock.send(pq);
        sock.receiveTimeout(pqresp, 3, 0);
        std::cout << "msgToREceiveOffset: " << msgToReceive->length
                  << std::endl;
        ans = (char *)realloc(ans, msgToSend->offset + msgToReceive->length);
        memcpy(ans + msgToSend->offset, msgToReceive->arguments,
               msgToReceive->length);
        msgToSend->offset += msgToReceive->length;
        std::cout << msgToSend->offset << std::endl;
        break;
      } catch (const char *msg) {
        std::cerr << msg << '\n';
      }
    }
    if (i == 7) {
      len_reply = 0;
      throw "All attempts failed, server not available";
    }
  }
  len_reply = msgToSend->offset;
  ImagePacket *img = (ImagePacket *)ans;
  std::cout << img->quality << std::endl;
  std::cout << "Image Name:" << std::endl;
  std::cout << img->name << std::endl;
  return ans;
}

Request::Request() {}

--------------------------------------------------------------------------------------------

#include "DatagramSocket.h"
#include "Message.h"

#ifndef REQUEST_H
#define REQUEST_H

class Request {
    public:
        Request();
        static char* doOperation(const std::string addr, uint16_t iport, Message::AllowedOperations operation, char *arguments, size_t len, size_t & len_reply);
};
#endif

***********************************************************************************

#include <chrono>
#include <fstream>
#include <iostream>
#include <string.h>
#include <string>
#include <sys/stat.h>
#include <thread>
#include <unordered_map>

#include "ImagePacket.h"
#include "Reply.h"
#include "Util.h"

using namespace std;

string genFileName(string ip, uint64_t requestId) {
  return ip + "_" + to_string(requestId) + ".png";
}

size_t getFileSize(string path) {
  struct stat stat_buf;
  int rc = stat(path.c_str(), &stat_buf);
  return rc == 0 ? stat_buf.st_size : -1;
}

char *captureScreenShot(string path, u_short quality) {
  string sysCommand = "scrot -q " + to_string(quality) + " " + path;
  system(sysCommand.c_str());
  std::this_thread::sleep_for(std::chrono::milliseconds(200));
  ifstream file;
  file.open(path, ios::in | ios::binary | ios::ate);
  char *img;
  if (file.is_open()) {
    streampos size = file.tellg();
    img = new char[size];
    file.seekg(0, ios::beg);
    file.read(img, size);
    char *aux = new char[size];
    file.close();
  }
  return img;
}

int main(int argc, char *argv[]) {
  uint16_t puerto;
  cout << "Puerto en el que se va a escuchar: ";
  cin >> puerto;
  Reply reply(puerto);
  cout << "Servidor iniciado...\n";
  unordered_map<string, int> nbd;
  while (1) {
    Message *msg = reply.getRequest();
    int *nums = (int *)msg->arguments;
    // cout << "Solicitud enviada desde el cliente " << reply.address << ":" <<
    // reply.port << "\n"; cout << " requestId=" << msg->requestId << "\n"; cout
    // << " operation =" << msg->operation << "\n"; cout << " sizeof(args)=" <<
    // msg->length << "\n";
    if (msg->operation == Message::AllowedOperations::sum) {
      // cout << " Numeros a sumar: " << nums[0] << " y " << nums[1] << "\n";
      int suma = nums[0] + nums[1];
      reply.sendReply((char *)&suma, sizeof(suma));
    } else if (msg->operation == Message::AllowedOperations::transfer) {
      nbd[reply.address] += nums[0];
      reply.sendReply((char *)&nbd[reply.address], sizeof(int));
    } else if (msg->operation == Message::AllowedOperations::getBalance) {
      reply.sendReply((char *)&nbd[reply.address], sizeof(int));
    } else if (msg->operation == Message::AllowedOperations::image) {
      string filename = genFileName(reply.address, reply.requestId);
      ImagePacket *imgpackIn = (ImagePacket *)msg->arguments;
      char *img = captureScreenShot("tmp/" + filename, imgpackIn->quality);
      size_t dataLen = getFileSize("tmp/" + filename);
      
      ImagePacket *imgpackOut = new ImagePacket(filename.c_str(), imgpackIn->quality, img, dataLen);
      reply.sendReply((char *)imgpackOut, dataLen + sizeof(unsigned short) + sizeof(char) * filename.size());
    }
    // cout << "\n";
  }
  return 0;
}

***********************************************************************************************

#include "Util.h"
#include <chrono>
#include <random>
using namespace std;
mt19937_64 seed(chrono::steady_clock::now().time_since_epoch().count());

const double Util::PI = acos(-1);

unsigned long long Util::random(unsigned long long min, unsigned long long max) { // [min, max]
  return uniform_int_distribution<unsigned long long>(min, max)(seed);
}
double Util::random(double min, double max) { // [min, max)
  return uniform_real_distribution<double>(min, max)(seed);
}

int Util::mod(int a, int b) {
  if (a < 0 && b >= 0)
    return a % b + b;
  if (a >= 0 && b < 0)
    return -(a % b + b);
  return a % b;
}

-----------------------------------------------------------------------------------------------

#ifndef UTIL_H
#define UTIL_H
class Util {
  public:
    static const double PI;
    static unsigned long long random(unsigned long long min, unsigned long long max);
    static double random(double min, double max);
    static int mod(int a, int b);
};
#endif

***************************************************************************************

<html>
<head>
<style>
div.gallery {
  margin: 5px;
  border: 1px solid #ccc;
  float: left;
  width: 180px;
}

div.gallery:hover {
  border: 1px solid #777;
}

div.gallery img {
  width: 100%;
  height: auto;
}

div.desc {
  padding: 15px;
  text-align: center;
}
</style>
</head>
<body>

<div *ngFor="let imgId of images;">
	<div class="gallery">
	  <a target="_blank" href="img_5terre.jpg">
	    <img src="{{imgId}}.jpg" width="600" height="400">
	  </a>
	</div>
</div>

</body>
</html>
